// File: specs/agent_collaboration_framework.pseudo
// Version: 1.0
// Description: Manages interaction, task assignment, and data flow between AI agents.

MODULE AgentCollaborationFramework

  // --- Dependencies ---
  IMPORT Agent (ProgrammeExpert, CreativeIdeator, StartupFounder, PracticalJudge, ProposalWriter)
  IMPORT LocalDatabase
  IMPORT IterativeWorkflowEngine

  // --- State ---
  DEFINE current_project_id AS STRING OR NULL
  DEFINE active_agents AS LIST<Agent>
  DEFINE task_queue AS QUEUE<Task>
  DEFINE project_context AS DICTIONARY // Shared context: current ideas, evaluations, drafts

  // --- Constants ---
  DEFINE MAX_CONCURRENT_TASKS = 5 // Example: One per agent

  // --- Initialization ---
  FUNCTION initialize(project_id):
    // TDD_ANCHOR: test_framework_initialization
    SET current_project_id = project_id
    SET active_agents = [ProgrammeExpert, CreativeIdeator, StartupFounder, PracticalJudge, ProposalWriter] // Instantiate or load agents
    CLEAR task_queue
    SET project_context = LocalDatabase.load_project_context(project_id)
    IF project_context IS EMPTY THEN
      SET project_context = { ideas: [], evaluations: [], drafts: [], history: [] }
    ENDIF
    LOG "Agent Collaboration Framework initialized for project: " + project_id
  END FUNCTION

  // --- Core Logic ---
  FUNCTION assign_task(agent_role, task_details):
    // TDD_ANCHOR: test_task_assignment_to_correct_agent
    // TDD_ANCHOR: test_task_queue_handling
    DEFINE task = CREATE Task(agent_role, task_details, current_project_id)
    ADD task TO task_queue
    LOG "Task added to queue for agent: " + agent_role
    CALL process_task_queue() // Attempt to process immediately if possible
  END FUNCTION

  FUNCTION process_task_queue():
    // TDD_ANCHOR: test_task_processing_limit
    // TDD_ANCHOR: test_agent_execution_and_result_handling
    WHILE task_queue IS NOT EMPTY AND count_active_tasks() < MAX_CONCURRENT_TASKS:
      DEFINE task = GET NEXT task FROM task_queue
      DEFINE target_agent = find_agent_by_role(task.agent_role)

      IF target_agent IS NOT NULL THEN
        LOG "Assigning task to agent: " + task.agent_role
        // Asynchronous execution is implied here
        ASYNC target_agent.execute_task(task.details, project_context) HANDLER handle_agent_result
      ELSE
        LOG_ERROR "Agent role not found: " + task.agent_role
        // Handle error: requeue, notify, etc.
      ENDIF
    ENDWHILE
  END FUNCTION

  FUNCTION handle_agent_result(agent_role, result):
    // TDD_ANCHOR: test_agent_result_updates_context
    // TDD_ANCHOR: test_agent_result_saves_to_db
    // TDD_ANCHOR: test_agent_result_triggers_workflow
    LOG "Received result from agent: " + agent_role
    UPDATE project_context WITH result.updates // Merge results (new ideas, evaluations, etc.)
    ADD result.history_entry TO project_context.history

    // Persist changes
    LocalDatabase.save_project_context(current_project_id, project_context)

    // Notify workflow engine about the update
    IterativeWorkflowEngine.notify_update(current_project_id, agent_role, result)

    // Check if more tasks can be processed
    CALL process_task_queue()
  END FUNCTION

  // --- Helper Functions ---
  FUNCTION find_agent_by_role(role_name):
    // TDD_ANCHOR: test_find_agent_by_role_success
    // TDD_ANCHOR: test_find_agent_by_role_failure
    FOR agent IN active_agents:
      IF agent.role == role_name:
        RETURN agent
      ENDIF
    ENDFOR
    RETURN NULL
  END FUNCTION

  FUNCTION count_active_tasks():
    // TDD_ANCHOR: test_count_active_tasks
    // Implementation depends on how async tasks are tracked
    DEFINE count = 0
    // LOGIC to count tasks currently being executed by agents
    RETURN count
  END FUNCTION

  // --- Data Structures ---
  DEFINE STRUCTURE Task:
    agent_role AS STRING
    details AS DICTIONARY // Specific instructions, data needed
    project_id AS STRING
  END STRUCTURE

END MODULE