# Coding Standards

- **Use TypeScript and Strict Typing**: All code must be written in TypeScript (no introducing new plain JavaScript files). Enable the TypeScript compilerâ€™s strict mode (e.g., `strict: true` in tsconfig) to catch undefined behavior. Avoid using the `any` type or suppressing type errors; instead, define proper interfaces, enums, and types for data structures. Every function, variable, and module should have clear and explicit types.
- **Clear Documentation**: Provide documentation comments for all non-trivial code (using JSDoc/TSDoc style). Each public function or class should have a comment describing its purpose, parameters, and return values. Use comments to explain complex logic or important nuances, but do not write comments for self-explanatory code. Well-documented code helps others (and the AI) understand intent and usage.
- **Consistent Code Style**: Adhere to a consistent style guide across the project. Follow established linting rules (for example, ESLint with a recommended or custom config) and use an auto-formatter (like Prettier) to enforce uniform formatting. This includes conventions for indentation, semicolons, quotes, brace placement, etc. Consistency makes the code easier to read and maintain. All code should pass lint checks before being committed.
- **Maintainability and Readability**: Write clean code that is easy to understand. Use descriptive names for variables, functions, and classes (e.g., `calculateTotalPrice` instead of `calc` or `doWork`). Follow the Single Responsibility Principle: each function or module should do one thing well. If a function exceeds ~50 lines or tries to handle too many tasks, consider refactoring it into smaller functions. Avoid code duplication by abstracting common functionality into reusable functions or utilities.
- **Best Practices in Design**: Prefer simple, expressive code structures. Use modern ES6+/TypeScript features for clarity and brevity (such as arrow functions, spread/rest operators, `async/await` for async code). Avoid anti-patterns like deeply nested callbacks or excessive global variables. Where appropriate, favor pure functions and immutability for easier testing and reasoning. Ensure that error cases are handled (use try/catch around risky operations, check for `undefined` or null where it could occur) so the code fails gracefully.
 ## Database Interaction Standards
- Always separate database interaction logic from business logic.
- Use consistent, project-approved ORMs or query builders (e.g., SQLAlchemy, Prisma, TypeORM).
- Clearly document complex database interactions with explanatory comments.
- Avoid direct database queries scattered throughout business logic; centralize database queries in dedicated modules.
- Ensure database interaction methods handle exceptions gracefully and consistently.
