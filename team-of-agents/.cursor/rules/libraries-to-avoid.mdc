# List of Libraries to Avoid

- **Deprecated/Unmaintained Libraries**: Avoid libraries that are no longer maintained or officially deprecated. For example, the `request` package (formerly used for HTTP requests) is deprecated and should be replaced with maintained alternatives like `axios` or the built-in Fetch API. Using deprecated packages can introduce security and compatibility issues since they don’t receive updates.
- **Libraries with Known Security Issues**: Do not use packages that have a history of vulnerabilities or malicious behavior. For instance, the `event-stream` npm package was involved in a supply-chain attack (via a malicious subdependency), so it should be avoided or closely scrutinized if absolutely needed. Similarly, be cautious with packages like `colors` or `faker` in the aftermath of maintainer sabotage incidents; stick to stable versions or well-vetted alternatives.
- **Trivial Utility Packages**: Refrain from adding dependencies for very simple functionalities. A classic example is `left-pad` (a tiny package to pad strings) – instead of relying on such a package, use built-in string methods (`padStart`/`padEnd`) or write a small helper function. Every dependency adds overhead and potential risk, so avoid those that aren’t truly necessary.
- **Heavy, Monolithic Libraries**: Avoid using overly heavy libraries when lighter or native solutions exist. For example, `moment.js` is large and has performance overhead; prefer using native Date methods, the `Intl` API, or smaller libraries like `date-fns` or `Luxon` for date manipulation. Similarly, avoid importing an entire utility library (like Lodash) if you only need a couple of functions – use native equivalents or import just the needed submodules to keep the bundle/runtime lean.
- **Poorly Maintained Projects**: Be wary of libraries that show signs of neglect (e.g., no updates in years, lots of unresolved issues, or many community forks). An example might be an old ORM or framework version that hasn’t kept up with security patches. Prefer active projects with a healthy maintenance record. If you must use a less-maintained library, pin the version and monitor it closely for any emerging issues, or consider forking it to fix critical problems yourself.
